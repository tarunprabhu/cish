#include <llvm/Analysis/AssumptionCache.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Pass.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Utils.h>
#include <llvm/Transforms/Utils/Local.h>
#include <llvm/Transforms/Utils/PromoteMemToReg.h>

#include "Diagnostics.h"
#include "List.h"
#include "Map.h"
#include "Set.h"
#include "Vector.h"
#include "SourceInfo.h"

#include <regex>

using namespace llvm;

/// This LLVM pass moves all branch instructions into their own basic blocks
/// The intention is to make it to try and recreate a reasonable approximation
/// of the control flow in the result C-ish program without having to resort
/// to gotos everwhere
class CishPreparePass : public FunctionPass {
public:
  static char ID;

private:
  cish::Map<std::string, int> suffixes;
  cish::Set<std::string> vars;

private:
  bool shouldPromote(AllocaInst* alloca);
  std::string registerVar(const std::string& var);
  std::string getNewVar(const std::string& var, bool forceSuffix);

public:
  CishPreparePass();

  virtual StringRef getPassName() const override;
  virtual void getAnalysisUsage(AnalysisUsage& AU) const override;
  virtual bool runOnFunction(Function& f) override;
};

CishPreparePass::CishPreparePass() : FunctionPass(ID) {
  ;
}

StringRef CishPreparePass::getPassName() const {
  return "Cish Prepare Pass";
}

void CishPreparePass::getAnalysisUsage(AnalysisUsage& AU) const {
  AU.addRequired<SourceInfoWrapperPass>();
  AU.addRequired<AssumptionCacheTracker>();
  AU.addRequired<DominatorTreeWrapperPass>();
  AU.addRequired<LoopInfoWrapperPass>();
}

bool CishPreparePass::shouldPromote(AllocaInst* alloca) {
  // The only allocas we want to remove are those introduced by reg2mem and
  // the only uses they should have are stores and loads. If we get rid of
  // any others along the way, no real harm done. If the alloca was only
  // written to once and then read from multiple times, it should be
  // removed.
  cish::Vector<StoreInst*> stores;
  cish::Vector<LoadInst*> loads;
  for(Use& u : alloca->uses())
    if(auto* store = dyn_cast<StoreInst>(u.getUser()))
      stores.push_back(store);
    else if(auto* load = dyn_cast<LoadInst>(u.getUser()))
      loads.push_back(load);
    else
      return false;

  if(stores.size() != 1)
    return false;

  return true;
}

std::string CishPreparePass::registerVar(const std::string& var) {
  vars.insert(var);
  suffixes[var] = 0;

  return var;
}

std::string CishPreparePass::getNewVar(const std::string& var,
                                       bool forceSuffix) {
  if(not vars.contains(var) and (not forceSuffix))
    return registerVar(var);

  do {
    std::string newVar = var + std::to_string(suffixes[var]);
    if(not vars.contains(newVar)) {
      vars.insert(newVar);
      suffixes[var] += 1;
      return newVar;
    }
  } while(true);
}

static void collectLoops(Loop* loop, cish::Set<Loop*>& loops) {
  loops.insert(loop);
  for(Loop* subLoop : *loop)
    collectLoops(subLoop, loops);
}

static cish::Set<Loop*> collectLoops(LoopInfo& li) {
  cish::Set<Loop*> loops;
  for(Loop* loop : li)
    collectLoops(loop, loops);
  return loops;
}

bool CishPreparePass::runOnFunction(Function& f) {
  cish::message() << "Running " << getPassName() << " on " << f.getName()
                  << "\n";

  LLVMContext& context = f.getContext();

  const cish::SourceInfo& si
      = getAnalysis<SourceInfoWrapperPass>().getSourceInfo();
  DominatorTree& dt = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
  AssumptionCache& ac
      = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(f);
  LoopInfo& li = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();

  // Collect the known names
  for(const Argument& arg : f.args())
    if(si.hasName(arg))
      registerVar(si.getName(arg));
  for(const Instruction& inst : instructions(f))
    if(const auto* alloca = dyn_cast<AllocaInst>(&inst))
      if(si.hasName(alloca))
        registerVar(si.getName(alloca));

  // Re-promote some of the allocas generated by reg2mem. If this seems
  // ridiculous, it's because calling DemoteRegToMemory only for PHI Nodes
  // is not as straightforward as I would like
  std::vector<AllocaInst*> allocas;
  for(Instruction& inst : instructions(f)) {
    if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
      if(shouldPromote(alloca))
        allocas.push_back(alloca);
    }
  }
  PromoteMemToReg(allocas, dt, &ac);

  MDNode* emptyMDNode = MDNode::get(context, ArrayRef<Metadata*>());

  // Try to give the allocas more useful names if possible. Some of these
  // allocas probably correspond to variables in the source code. If debug
  // information is available, we can probably use it.
  // If the instruction has debug information associated with it, check if the
  // value is stored to an alloca. Pick the name most frequently stored to
  // the alloca and use it.

  // FIXME? (Maybe?): This is a bit hacky because it relies on
  // reg2mem naming the variables that it inserts a certain way.
  // Those are unlikely to change, but you never know
  std::regex re("^(.*)[.]reg2mem[.]?[0-9]*$");
  for(Instruction& inst : instructions(f)) {
    if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
      std::string name = alloca->getName().str();
      if(std::regex_match(name, re)) {
        cish::Map<std::string, unsigned> srcNames;
        for(Use& u : alloca->uses())
          // The allocas introduced by reg2mem are themselves "temporaries"
          // of a sort, so don't ever use temporaries for them. This is safe
          // because the values will always get written out if there is a
          // chance of multiple paths accessing the value through a PHI node
          if(auto* load = dyn_cast<LoadInst>(u.getUser()))
            load->setMetadata("cish.notemp", emptyMDNode);
          else if(auto* store = dyn_cast<StoreInst>(u.getUser()))
            if(si.hasName(store->getValueOperand()))
              ++srcNames[si.getName(store->getValueOperand())];
        if(srcNames.size())
          alloca->setName(
              getNewVar(std::max_element(srcNames.begin(),
                                         srcNames.end(),
                                         [](const auto& a, const auto& b) {
                                           return a.second < b.second;
                                         })
                            ->first,
                        false));
        else
          alloca->setName(getNewVar("_t", true));
      }
    } else {
      inst.getParent()->splitBasicBlock(&inst);
      break;
    }
  }

  // Move the branch instruction in the exiting branch of a loop to its own
  // basic block. Also make the header an empty block so it only acts as
  // the target of a backedge and does nothing else
  cish::Set<Loop*> loops = collectLoops(li);
  cish::Map<BasicBlock*, Loop*> preheaders;
  for(Loop* loop : loops) {
    SmallVector<BasicBlock*, 4> exiting;
    loop->getExitingBlocks(exiting);
    for(BasicBlock* bb : exiting)
      bb->splitBasicBlock(&bb->back());
    BasicBlock* header = loop->getHeader();
    header->splitBasicBlock(&header->front());
    if(BasicBlock* preheader = loop->getLoopPreheader())
      preheaders[preheader] = loop;
  }

  // Move switch instructions into their own basic block
  cish::List<Instruction*> switches;
  for(Instruction& inst : instructions(f))
    if(isa<SwitchInst>(inst))
      switches.push_back(&inst);
  for(Instruction* inst : switches)
    inst->getParent()->splitBasicBlock(inst);

  cish::Map<AllocaInst*, cish::Set<Loop*>> usesInLoops;
  for(Instruction& inst : instructions(f)) {
    if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
      for(Use& u : alloca->uses()) {
        if(auto* i = dyn_cast<Instruction>(u.getUser())) {
          if(isa<LoadInst>(u.getUser()) or isa<StoreInst>(u.getUser())) {
            BasicBlock* bb = i->getParent();
            if(Loop* loop = li.getLoopFor(bb))
              usesInLoops[alloca].insert(loop);
            if(preheaders.contains(bb))
              usesInLoops[alloca].insert(preheaders.at(bb));
          }
        }
      }
    }
  }

  return true;
}

char CishPreparePass::ID = 0;

static RegisterPass<CishPreparePass>
    X("cish-prepare", "Prepare code for cish", false, false);

Pass* createCishPreparePass() {
  return new CishPreparePass();
}
