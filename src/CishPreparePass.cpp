#include <llvm/Analysis/AssumptionCache.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Pass.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Utils.h>
#include <llvm/Transforms/Utils/Local.h>
#include <llvm/Transforms/Utils/PromoteMemToReg.h>

#include "List.h"
#include "Set.h"
#include "SourceInfo.h"

#include <regex>

using namespace llvm;

/// This LLVM pass moves all branch instructions into their own basic blocks
/// The intention is to make it to try and recreate a reasonable approximation
/// of the control flow in the result C-ish program without having to resort
/// to gotos everwhere
class CishPreparePass : public FunctionPass {
public:
  static char ID;

public:
  CishPreparePass();

  virtual StringRef getPassName() const override;
  virtual void getAnalysisUsage(AnalysisUsage& AU) const override;
  virtual bool runOnFunction(Function& f) override;
};

CishPreparePass::CishPreparePass() : FunctionPass(ID) {
  ;
}

StringRef CishPreparePass::getPassName() const {
  return "CISH Prepare Pass";
}

void CishPreparePass::getAnalysisUsage(AnalysisUsage& AU) const {
  AU.addRequired<SourceInfoWrapperPass>();
  AU.addRequired<AssumptionCacheTracker>();
  AU.addRequired<DominatorTreeWrapperPass>();
  AU.addRequired<LoopInfoWrapperPass>();
}

static bool shouldPromote(AllocaInst* alloca, const DominatorTree& dt) {
  // The only allocas we want to remove are those introduced by reg2mem and
  // the only uses they should have are stores and loads. If we get rid of
  // any others along the way, no real harm done
  cish::Vector<StoreInst*> stores;
  cish::Vector<LoadInst*> loads;
  for(Use& u : alloca->uses())
    if(auto* store = dyn_cast<StoreInst>(u.getUser()))
      stores.push_back(store);
    else if(auto* load = dyn_cast<LoadInst>(u.getUser()))
      loads.push_back(load);
    else
      return false;

  if(stores.size() != 1)
    return false;

  for(LoadInst* load : loads)
    if(not dt.dominates(stores[0], load))
      return false;
  return true;
}

static void collectLoops(Loop* loop, cish::Set<Loop*>& loops) {
  loops.insert(loop);
  for(Loop* subLoop : *loop)
    collectLoops(subLoop, loops);
}

bool CishPreparePass::runOnFunction(Function& f) {
  LLVMContext& context = f.getContext();

  const cish::SourceInfo& si
      = getAnalysis<SourceInfoWrapperPass>().getSourceInfo();
  DominatorTree& dt = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
  AssumptionCache& ac
      = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(f);
  LoopInfo& li = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();

  // This is a bit hacky because it relies on reg2mem naming the variables that
  // it inserts a certain way. Those are unlikely to change, but you never know
  std::regex re("[.]reg2mem[.]?[0-9]*$");
  MDNode* md = MDNode::get(context, ArrayRef<Metadata*>());
  for(Instruction& inst : instructions(f)) {
    if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
      std::string name = alloca->getName().str();
      if(std::regex_match(name, re)) {
        alloca->setName(std::regex_replace(alloca->getName().str(), re, "_r"));
        for(Use& u : alloca->uses())
          // The allocas introduced by reg2mem are themselves "temporaries"
          // of a sort, so don't ever use temporaries for them. This is safe
          // because the values will always get written out if there is a
          // chance of multiple paths accessing the value through a PHI node
          if(auto* load = dyn_cast<LoadInst>(u.getUser()))
            load->setMetadata("cish.notemp", md);
      }
    } else {
      inst.getParent()->splitBasicBlock(&inst);
      break;
    }
  }

  // Re-promote some of the allocas generated by reg2mem. Only promote those
  // allocas that are only used in a single basic block
  std::vector<AllocaInst*> allocas;
  for(Instruction& inst : instructions(f)) {
    if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
      if(shouldPromote(alloca, dt))
        allocas.push_back(alloca);
    }
  }

  PromoteMemToReg(allocas, dt, &ac);

  // Move the branch instruction in the exiting branch of a loop to its own
  // basic block. Also make the header an empty block so it only acts as
  // the target of a backedge and does nothing else
  cish::Set<Loop*> loops;
  for(Loop* loop : li)
    collectLoops(loop, loops);
  for(Loop* loop : loops) {
    SmallVector<BasicBlock*, 4> exiting;
    loop->getExitingBlocks(exiting);
    for(BasicBlock* bb : exiting)
      bb->splitBasicBlock(&bb->back());
    BasicBlock* header = loop->getHeader();
    header->splitBasicBlock(&header->front());
  }

  return true;
}

char CishPreparePass::ID = 0;

static RegisterPass<CishPreparePass>
    X("cish-prepare", "Prepare code for cish", false, false);

Pass* createCishPreparePass() {
  return new CishPreparePass();
}
