#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/Analysis/LoopPass.h>
#include <llvm/Analysis/Passes.h>
#include <llvm/Analysis/ScalarEvolution.h>
#include <llvm/IR/DebugInfo.h>
#include <llvm/IR/Dominators.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/Metadata.h>
#include <llvm/IR/Module.h>
#include <llvm/Pass.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/WithColor.h>
#include <llvm/Support/raw_ostream.h>

#include "ASTBase.h"
#include "Context.h"
#include "LLVMUtils.h"
#include "Map.h"
#include "Printer.h"
#include "Set.h"
#include "Vector.h"

using namespace llvm;

enum class IgnoreCasts {
  None,
  Function,
  Vector,
  All,
};

enum class Annotations {
  Source,
  Cish,
  All,
};

static cl::list<IgnoreCasts> OptIgnoreCasts(
    "cish-ignore-casts",
    cl::desc("Which casts, if any, to ignore"),
    cl::values(clEnumValN(IgnoreCasts::Function,
                          "function",
                          "Ignore casts to function types"),
               clEnumValN(IgnoreCasts::Vector,
                          "vector",
                          "Ignore casts to vector types"),
               clEnumValN(IgnoreCasts::All, "all", "Ignore all casts")));

static cl::opt<std::string> OptPrefix(
    "cish-prefix",
    cl::desc("The prefix to use for any names auto-generated by cish"),
    cl::init("c__"));

static cl::list<Annotations> OptAnnotations(
    "cish-annotate",
    cl::desc("Add annotations to the output"),
    cl::values(
        clEnumValN(Annotations::Source,
                   "source",
                   "Annotate with source code if available"),
        clEnumValN(Annotations::Cish,
                   "cish",
                   "Annotations from cish that may or may not be helpful"),
        clEnumValN(Annotations::All, "all", "Add all kinds of annotations")));

static cl::opt<bool> OptQuit("cish-quiet",
                             cl::desc("Do not print any messages"),
                             cl::init(false));

class CishPass : public ModulePass {
public:
  static char ID;

protected:
  cish::Context ctxt;

  // Options from the command line
  cish::Set<IgnoreCasts> ignoreCasts;
  cish::Set<Annotations> annotations;

  // The values to tbe ignored when converting
  cish::Set<const llvm::Value*> ignoreValues;

  // When processing llvm::ConstantExpr, we may end up creating an instruction
  // that implements the same operation. Those are kept here for easy cleanup.
  // Right now, we only make one pass over the function, but if that ever
  // changes, better to have it around so it's not converted every time
  cish::Map<const llvm::ConstantExpr*,
            std::unique_ptr<Instruction, std::function<void(Instruction*)>>>
      cexprs;

  // The actual C code for the current function is here. It should be
  // cleared either after the function is done or before a new function is
  // started
  cish::Printer cc;

protected:
  void initialize(const Function& f);
  void initialize(const Module& m);
  void finalize(const Module& m);
  bool allUsesIgnored(const Value* v) const;
  bool shouldUseTemporary(const Instruction& inst);
  const llvm::Instruction&
  getInstructionForConstantExpr(const ConstantExpr& cexpr);

  const std::string& formatExpr(const cish::Expr& expr);
  std::string formatOperator(const std::string& op, const BinaryOperator& inst);

  const cish::ASTBase& handle(const AllocaInst& alloca);
  const cish::ASTBase& handle(const LoadInst& load);
  const cish::ASTBase& handle(const StoreInst& store);
  const cish::ASTBase& handle(const GetElementPtrInst& gep);
  const cish::ASTBase& handle(const PHINode& phi);
  const cish::ASTBase& handle(const CallInst& call);
  const cish::ASTBase& handle(const InvokeInst& invoke);
  const cish::ASTBase& handle(const CmpInst& cmp);
  const cish::ASTBase& handle(const BinaryOperator& op);
  const cish::ASTBase& handle(const UnaryOperator& op);
  const cish::ASTBase& handle(const CastInst& cst);
  const cish::ASTBase& handle(const BranchInst& br);
  const cish::ASTBase& handle(const SwitchInst& sw);
  const cish::ASTBase& handle(const SelectInst& select);
  const cish::ASTBase& handle(const ReturnInst& ret);
  const cish::ASTBase& handle(const ShuffleVectorInst& shuffle);

  const cish::ASTBase& handle(const Function& f);
  const cish::ASTBase& handle(const GlobalVariable& g);
  const cish::ASTBase& handle(const Argument& arg);

  const cish::ASTBase& handle(const ConstantInt& cint);
  const cish::ASTBase& handle(const ConstantFP& cfp);
  const cish::ASTBase& handle(const ConstantPointerNull& cnull);
  const cish::ASTBase& handle(const ConstantExpr& cexpr);
  const cish::ASTBase& handle(const UndefValue& undef);
  const cish::ASTBase& handle(const ConstantDataArray& cda);
  const cish::ASTBase& handle(const ConstantArray& carray);
  const cish::ASTBase& handle(const ConstantStruct& cstruct);
  const cish::ASTBase& handle(const ConstantVector& cvec);

  const cish::ASTBase& handle(const BasicBlock& bb);

  const cish::ASTBase& handle(const Value* v);

  const cish::ASTBase& handle(IntegerType* ity);
  const cish::ASTBase& handle(PointerType* pty);
  const cish::ASTBase& handle(ArrayType* aty);
  const cish::ASTBase& handle(FunctionType* fty);
  const cish::ASTBase& handle(StructType* sty);
  const cish::ASTBase& handle(VectorType* vty);
  const cish::ASTBase& handle(Type* type);

  void handleIndices(Type* ty,
                     unsigned idx,
                     const cish::Vector<const Value*>& indices,
                     const Instruction& inst,
                     raw_string_ostream& ss);

  bool runOnFunction(Function& f);
  bool runOnGlobal(GlobalVariable& g);
  bool runOnStruct(StructType* sty);

public:
  CishPass();

  virtual StringRef getPassName() const override;
  void getAnalysisUsage(AnalysisUsage& AU) const override;
  virtual void print(raw_ostream& o, const Module* m) const override;

  virtual bool runOnModule(Module& m) override;
};

CishPass::CishPass() : ModulePass(ID), ctxt(OptPrefix), cc(ctxt) {
  for(IgnoreCasts ignore : OptIgnoreCasts)
    ignoreCasts.insert(ignore);

  for(Annotations a : OptAnnotations)
    annotations.insert(a);

  if(annotations.size())
    WithColor::warning(errs()) << "Annotations not implemented\n";
}

StringRef CishPass::getPassName() const {
  return "CISH Loop Pass";
}

void CishPass::getAnalysisUsage(AnalysisUsage& AU) const {
  AU.addRequired<LoopInfoWrapperPass>();
  AU.addRequired<DominatorTreeWrapperPass>();
  AU.addRequired<ScalarEvolutionWrapperPass>();
  AU.setPreservesAll();
}

void CishPass::print(raw_ostream& o, const Module* module) const {
  o << cc.str() << "\n";
}

const Instruction&
CishPass::getInstructionForConstantExpr(const ConstantExpr& cexpr) {
  if(not cexprs.contains(&cexpr))
    // ********************* HORRENDOUS EVIL AHEAD *************************
    //
    // FIXME: Make this go away ASAP!
    //
    // ConstantExpr for LLVM 8.0 (that this was originally developed with)
    // is not marked const, but it is in later versions. I don't think
    // anything has actually changed in the code between the two versions.
    // And I really don't want to "un-const" everything here. So just
    // cast away the const and forge ahead.
    //
    // ---------------------------------------------------------------------
    cexprs[&cexpr]
        = std::unique_ptr<Instruction, std::function<void(Instruction*)>>(
            const_cast<ConstantExpr&>(cexpr).getAsInstruction(),
            [](Instruction* inst) { inst->deleteValue(); });

  return *cexprs.at(&cexpr);
}

const std::string& CishPass::formatExpr(const cish::Expr& expr) {
  const llvm::Value& val = expr.getLLVM();
  if(ctxt.isOverwrite(expr.getLLVM()))
    return expr.str();
  else if(isa<BinaryOperator>(val) or isa<CmpInst>(val))
    return expr.getParenthetized();
  else
    return expr.str();
}

std::string CishPass::formatOperator(const std::string& op,
                                     const BinaryOperator& inst) {
  if(auto* vecTy = dyn_cast<VectorType>(inst.getOperand(0)->getType())) {
    std::string buf;
    raw_string_ostream ss(buf);
    unsigned count = vecTy->getNumElements() / 2;
    for(unsigned i = 0; i < count; i++)
      ss << "<";
    ss << op;
    for(unsigned i = 0; i < count; i++)
      ss << ">";
    return ss.str();
  }
  return op;
}

const cish::ASTBase& CishPass::handle(const Function& f) {
  FunctionType* fty = f.getFunctionType();
  handle(fty->getReturnType());
  for(Type* type : fty->params())
    handle(type);

  if(const DISubprogram* di = f.getSubprogram())
    return ctxt.add(f, di->getName());
  else if(ctxt.hasSourceName(f))
    return ctxt.add(f, ctxt.getSourceName(f));
  else
    return ctxt.add(f, f.getName().str());
}

const cish::ASTBase& CishPass::handle(const GlobalVariable& g) {
  if(g.hasName()) {
    return ctxt.add(g, g.getName().str());
  } else if(ctxt.hasSourceName(g)) {
    return ctxt.add(g, ctxt.getSourceName(g));
  } else {
    return ctxt.add(g, ctxt.getNewVar("g"));
  }
}

const cish::ASTBase& CishPass::handle(const Argument& arg) {
  std::string name;
  if(arg.hasName()) {
    name = arg.getName().str();
  } else if(ctxt.hasSourceName(arg)) {
    name = ctxt.getSourceName(arg);
  } else {
    std::string buf;
    raw_string_ostream ss(buf);
    ss << "arg_" << arg.getArgNo();
    name = ss.str();
  }

  // We could look for dereferenceable bytes in the argument and then display
  // it as a byref parameter, but that gets problematic because then we would
  // also have to go in and handle anything that was originally a reference
  // in the original code. The point is not really to get back the original
  // code but make it easier to understand what the compiler has done to the
  // code. In this case, it is good to understand that what is a reference in
  // C++ is just a non-null pointer under the hood.
  //
  // FIXME: Add argument attributes like const, restrict, non-null etc. that
  // were inferred by the compiler and/or were present in the original code
  ctxt.add<cish::Decl>(arg, handle(arg.getType()), " ", name);
  return ctxt.add<cish::Expr>(arg, name);
}

const cish::ASTBase& CishPass::handle(const ConstantInt& cint) {
  const APInt& value = cint.getValue();
  if(value.isNegative())
    // Cast to int64_t so we actually get the sign because
    // value.getLimitedValue() returns a uint64_t.
    return ctxt.add(cint, (int64_t)value.getLimitedValue());
  else
    return ctxt.add(cint, value.getLimitedValue());
}

const cish::ASTBase& CishPass::handle(const ConstantFP& cfp) {
  std::string buf;
  raw_string_ostream ss(buf);
  cfp.getValueAPF().print(ss);
  // print() adds a newline at the end of the converted string. Obviously
  // we don't want it
  ss.flush();
  return ctxt.add(cfp, buf.substr(0, buf.length() - 1));
}

const cish::ASTBase& CishPass::handle(const ConstantPointerNull& cnull) {
  return ctxt.add(cnull, "NULL");
}

const cish::ASTBase& CishPass::handle(const UndefValue& undef) {
  return ctxt.add(undef, "__undef__");
}

const cish::ASTBase& CishPass::handle(const ConstantArray& carray) {
  WithColor::error(errs()) << "UNIMPLEMENTED: CONSTANT ARRAY\n";
  exit(1);
}

const cish::ASTBase& CishPass::handle(const ConstantDataArray& cda) {
  WithColor::error(errs()) << "UNIMPLEMENTED: CONSTANT DATA ARRAY\n";
  exit(1);
}

const cish::ASTBase& CishPass::handle(const ConstantStruct& cstruct) {
  WithColor::error(errs()) << "UNIMPLEMENTED: CONSTANT STRUCT\n";
  exit(1);
}

const cish::ASTBase& CishPass::handle(const ConstantVector& cvec) {
  WithColor::error(errs()) << "UNIMPLEMENTED: CONSTANT VECTOR\n";
  exit(1);
}

const cish::ASTBase& CishPass::handle(const ConstantExpr& cexpr) {
  return ctxt.add(cexpr, handle(&getInstructionForConstantExpr(cexpr)));
}

const cish::ASTBase& CishPass::handle(const AllocaInst& alloca) {
  std::string name;
  if(alloca.hasName())
    name = alloca.getName();
  else if(ctxt.hasSourceName(alloca))
    name = ctxt.getSourceName(alloca);
  else
    name = ctxt.getNewVar("local");

  ctxt.add<cish::Stmt>(alloca, handle(alloca.getAllocatedType()), " ", name);
  return ctxt.add<cish::Expr>(alloca, name);
}

const cish::ASTBase& CishPass::handle(const CastInst& cst) {
  const llvm::Value* op = cst.getOperand(0);
  llvm::Type* dest = cst.getDestTy();

  if(ignoreCasts.contains(IgnoreCasts::All))
    return ctxt.add(cst, handle(op));

  if(ignoreCasts.contains(IgnoreCasts::Function)
     and (dest->isFunctionTy() or isPointerToType<FunctionType>(dest)))
    return ctxt.add(cst, handle(op));

  if(ignoreCasts.contains(IgnoreCasts::Vector)
     and (dest->isVectorTy() or isPointerToType<VectorType>(dest)))
    return ctxt.add(cst, handle(op));

  return ctxt.add(cst, "(", handle(dest), ")", handle(op));
}

const cish::ASTBase& CishPass::handle(const BranchInst& br) {
  for(const llvm::BasicBlock* bb : br.successors())
    handle(bb);
  if(br.isConditional()) {
    handle(br.getCondition());
    return ctxt.add(br);
  } else {
    return ctxt.add<cish::Stmt>(br, "goto ", handle(br.getSuccessor(0)));
  }
}

const cish::ASTBase& CishPass::handle(const LoadInst& load) {
  const Value* ptr = load.getPointerOperand();
  const std::string& s = handle(ptr).str();

  // If the pointer operand begins with an '&', just remove it because that
  // and '*' "cancel" each other out.
  if(s[0] == '&')
    return ctxt.add(load, handle(ptr).str().substr(1));
  else
    return ctxt.add(load, "*", handle(ptr));
}

const cish::ASTBase& CishPass::handle(const StoreInst& store) {
  const std::string& dest = handle(store.getPointerOperand()).str();
  const std::string& src = handle(store.getValueOperand()).str();

  // If the pointer operand begins with an '&', just remove it because that
  // and '*' "cancel" each other out.
  if(dest[0] == '&')
    return ctxt.add<cish::Stmt>(store, dest.substr(1), " = ", src);
  else
    return ctxt.add<cish::Stmt>(store, "*", dest, " = ", src);
}

void CishPass::handleIndices(Type* ty,
                             unsigned idx,
                             const cish::Vector<const Value*>& indices,
                             const Instruction& inst,
                             raw_string_ostream& ss) {
  const Value* op = indices[idx];
  Type* next = nullptr;
  if(auto* pty = dyn_cast<PointerType>(ty)) {
    ss << "[" << handle(op) << "]";
    next = pty->getElementType();
  } else if(auto* aty = dyn_cast<ArrayType>(ty)) {
    ss << "[" << handle(op) << "]";
    next = aty->getElementType();
  } else if(auto* sty = dyn_cast<StructType>(ty)) {
    if(auto* cint = dyn_cast<ConstantInt>(op)) {
      unsigned field = cint->getLimitedValue();
      ss << "." << ctxt.getElementName(sty, field);
      next = sty->getElementType(field);
    } else {
      WithColor::error(errs()) << "Expected constant index in GEP\n"
                               << "          idx: " << idx << "\n"
                               << "           op: " << *op << "\n"
                               << "         type: " << *ty << "\n"
                               << "         inst: " << inst << "\n";
      exit(1);
    }
  } else {
    WithColor::error(errs())
        << "GEP Indices not implemented for type: " << *ty << "\n";
    exit(1);
  }

  if((idx + 1) < indices.size())
    handleIndices(next, idx + 1, indices, inst, ss);
}

const cish::ASTBase& CishPass::handle(const GetElementPtrInst& gep) {
  std::string buf;
  raw_string_ostream ss(buf);
  const llvm::Value* ptr = gep.getPointerOperand();
  auto* pty = dyn_cast<PointerType>(ptr->getType());
  const std::string& s = handle(gep.getPointerOperand()).str();

  // If the pointer operand is also a GEP and is not overwritten with a
  // temporary value, it will begin with a &. Obviously, we don't want that
  if(isa<GetElementPtrInst>(ptr) and not ctxt.isOverwrite(ptr))
    ss << s.substr(1);
  else
    ss << s;
  cish::Vector<const Value*> indices(gep.idx_begin(), gep.idx_end());
  handleIndices(pty, 0, indices, gep, ss);
  return ctxt.add(gep, "&", ss.str());
}

const cish::ASTBase& CishPass::handle(const PHINode& phi) {
  // FIXME: This is not really correct
  WithColor::warning(errs()) << "PHI nodes not correctly handled\n";
  return ctxt.add(phi, "PHI");
}

const cish::ASTBase& CishPass::handle(const CallInst& call) {
  std::string buf;
  raw_string_ostream ss(buf);
  ss << handle(call.getCalledValue()) << "(";
  if(call.getNumArgOperands()) {
    ss << handle(call.getArgOperand(0));
    for(unsigned i = 1; i < call.getNumArgOperands(); i++)
      ss << ", " << handle(call.getArgOperand(i));
  }
  ss << ")";
  if(call.getType()->isVoidTy())
    return ctxt.add<cish::Stmt>(call, ss.str());
  else
    return ctxt.add(call, ss.str());
}

const cish::ASTBase& CishPass::handle(const InvokeInst& invoke) {
  WithColor::error(errs()) << "UNIMPLEMENTED: " << invoke << "\n";
  exit(1);
  return ctxt.add(invoke, "");
}

const cish::ASTBase& CishPass::handle(const BinaryOperator& inst) {
  std::string op = "@@";

  switch(inst.getOpcode()) {
  case BinaryOperator::Add:
  case BinaryOperator::FAdd:
    op = formatOperator("+", inst);
    break;
  case BinaryOperator::Sub:
  case BinaryOperator::FSub:
    op = formatOperator("-", inst);
    break;
  case BinaryOperator::Mul:
  case BinaryOperator::FMul:
    op = formatOperator("*", inst);
    break;
  case BinaryOperator::UDiv:
  case BinaryOperator::FDiv:
  case BinaryOperator::SDiv:
    op = formatOperator("/", inst);
    break;
  case BinaryOperator::URem:
  case BinaryOperator::SRem:
  case BinaryOperator::FRem:
    op = formatOperator("%", inst);
    break;
  case BinaryOperator::Shl:
    op = "<<";
    break;
  case BinaryOperator::LShr:
    op = ">>";
    break;
  case BinaryOperator::And:
    op = "&";
    break;
  case BinaryOperator::Or:
    op = "|";
    break;
  case BinaryOperator::Xor:
    op = "^";
    break;
  default:
    WithColor::error(errs()) << "Unknown binary operator: " << inst << "\n";
    exit(1);
    break;
  }

  const std::string& op0
      = formatExpr(cast<cish::Expr>(handle(inst.getOperand(0))));
  const std::string& op1
      = formatExpr(cast<cish::Expr>(handle(inst.getOperand(1))));
  return ctxt.add(inst, op0, " ", op, " ", op1);
}

const cish::ASTBase& CishPass::handle(const UnaryOperator& inst) {
  std::string op = "@@";
  switch(inst.getOpcode()) {
  case UnaryOperator::FNeg:
    op = "-";
    break;
  default:
    WithColor::error(errs()) << "Unknown unary operator: " << inst << "\n";
    exit(1);
    break;
  }

  return ctxt.add(inst, op, handle(inst.getOperand(0)));
}

const cish::ASTBase& CishPass::handle(const CmpInst& cmp) {
  std::string op = "@@";
  switch(cmp.getPredicate()) {
  case CmpInst::FCMP_OEQ:
  case CmpInst::FCMP_UEQ:
  case CmpInst::ICMP_EQ:
    op = "==";
    break;
  case CmpInst::FCMP_ONE:
  case CmpInst::FCMP_UNE:
  case CmpInst::ICMP_NE:
    op = "!=";
    break;
  case CmpInst::FCMP_OGT:
  case CmpInst::FCMP_UGT:
  case CmpInst::ICMP_UGT:
  case CmpInst::ICMP_SGT:
    op = ">";
    break;
  case CmpInst::FCMP_OGE:
  case CmpInst::FCMP_UGE:
  case CmpInst::ICMP_UGE:
  case CmpInst::ICMP_SGE:
    op = ">=";
    break;
  case CmpInst::FCMP_OLT:
  case CmpInst::FCMP_ULT:
  case CmpInst::ICMP_ULT:
  case CmpInst::ICMP_SLT:
    op = "<";
    break;
  case CmpInst::FCMP_OLE:
  case CmpInst::FCMP_ULE:
  case CmpInst::ICMP_ULE:
  case CmpInst::ICMP_SLE:
    op = "<=";
    break;
  default:
    WithColor::error(errs()) << "Unknown compare predicate: " << cmp << "\n";
    exit(1);
    break;
  }

  const std::string& op0
      = formatExpr(cast<cish::Expr>(handle(cmp.getOperand(0))));
  const std::string& op1
      = formatExpr(cast<cish::Expr>(handle(cmp.getOperand(1))));
  return ctxt.add(cmp, op0, " ", op, " ", op1);
}

const cish::ASTBase& CishPass::handle(const SelectInst& select) {
  return ctxt.add(select,
                  "(",
                  formatExpr(cast<cish::Expr>(handle(select.getCondition()))),
                  " ? ",
                  formatExpr(cast<cish::Expr>(handle(select.getTrueValue()))),
                  " : ",
                  formatExpr(cast<cish::Expr>(handle(select.getFalseValue()))),
                  ")");
}

const cish::ASTBase& CishPass::handle(const SwitchInst& sw) {
  WithColor::error(errs()) << "UNIMPLEMENTED: " << sw << "\n";
  exit(1);
}

const cish::ASTBase& CishPass::handle(const ReturnInst& ret) {
  if(Value* value = ret.getReturnValue())
    return ctxt.add<cish::Stmt>(ret, "return ", handle(value));
  else
    return ctxt.add<cish::Stmt>(ret, "return");
}

const cish::ASTBase& CishPass::handle(const BasicBlock& bb) {
  return ctxt.add(bb, ctxt.getNewVar("bb"));
}

const cish::ASTBase& CishPass::handle(const Value* v) {
  if(ctxt.has(*v))
    return ctxt.get(*v);

  if(const auto* load = dyn_cast<LoadInst>(v))
    return handle(*load);
  else if(const auto* store = dyn_cast<StoreInst>(v))
    return handle(*store);
  else if(const auto* phi = dyn_cast<PHINode>(v))
    return handle(*phi);
  else if(const auto* call = dyn_cast<CallInst>(v))
    return handle(*call);
  else if(const auto* invoke = dyn_cast<InvokeInst>(v))
    return handle(*invoke);
  else if(const auto* gep = dyn_cast<GetElementPtrInst>(v))
    return handle(*gep);
  else if(const auto* cst = dyn_cast<CastInst>(v))
    return handle(*cst);
  else if(const auto* sw = dyn_cast<SwitchInst>(v))
    return handle(*sw);
  else if(const auto* select = dyn_cast<SelectInst>(v))
    return handle(*select);
  else if(const auto* ret = dyn_cast<ReturnInst>(v))
    return handle(*ret);
  else if(const auto* cmp = dyn_cast<CmpInst>(v))
    return handle(*cmp);
  else if(const auto* alloca = dyn_cast<AllocaInst>(v))
    return handle(*alloca);
  else if(const auto* binop = dyn_cast<BinaryOperator>(v))
    return handle(*binop);
  else if(const auto* unop = dyn_cast<UnaryOperator>(v))
    return handle(*unop);
  else if(const auto* f = dyn_cast<Function>(v))
    return handle(*f);
  else if(const auto* g = dyn_cast<GlobalVariable>(v))
    return handle(*g);
  else if(const auto* cint = dyn_cast<ConstantInt>(v))
    return handle(*cint);
  else if(const auto* cfp = dyn_cast<ConstantFP>(v))
    return handle(*cfp);
  else if(const auto* cnull = dyn_cast<ConstantPointerNull>(v))
    return handle(*cnull);
  else if(const auto* cexpr = dyn_cast<ConstantExpr>(v))
    return handle(*cexpr);
  else if(const auto* undef = dyn_cast<UndefValue>(v))
    return handle(*undef);
  else if(const auto* carray = dyn_cast<ConstantArray>(v))
    return handle(*carray);
  else if(const auto* cda = dyn_cast<ConstantDataArray>(v))
    return handle(*cda);
  else if(const auto* cstruct = dyn_cast<ConstantStruct>(v))
    return handle(*cstruct);
  else if(const auto* cvec = dyn_cast<ConstantVector>(v))
    return handle(*cvec);
  else if(const auto* bb = dyn_cast<BasicBlock>(v))
    return handle(*bb);
  else
    WithColor::error(errs()) << "UNHANDLED: " << *v << "\n";

  exit(1);
}

const cish::ASTBase& CishPass::handle(IntegerType* ity) {
  switch(ity->getBitWidth()) {
  case 1:
    return ctxt.add(ity, "bool");
  case 8:
    return ctxt.add(ity, "char");
  case 16:
    return ctxt.add(ity, "short");
  case 32:
    return ctxt.add(ity, "int");
  case 64:
    return ctxt.add(ity, "long");
  case 128:
    return ctxt.add(ity, "__int128_t");
  default:
    errs() << "Unexpected integer type: " << *ity << "\n";
  }

  std::string buf;
  raw_string_ostream ss(buf);
  ss << "int" << ity->getBitWidth() << "_t";
  return ctxt.add(ity, ss.str());
}

const cish::ASTBase& CishPass::handle(PointerType* pty) {
  std::string buf;
  raw_string_ostream ss(buf);
  ss << handle(pty->getElementType()) << "*";

  return ctxt.add(pty, ss.str());
}

const cish::ASTBase& CishPass::handle(ArrayType* aty) {
  // Arrays are problematic in C/C++ because the size of the array
  // ends up being attached to a variable. So this will return something
  // that looks C-ish, but definitely isn't valid C
  std::string buf;
  raw_string_ostream ss(buf);
  ss << handle(aty->getElementType()) << "[" << aty->getNumElements() << "]";

  return ctxt.add(aty, ss.str());
}

const cish::ASTBase& CishPass::handle(StructType* sty) {
  if(sty->hasName()) {
    std::string buf;
    raw_string_ostream ss(buf);
    StringRef sname = sty->getName();
    if(ctxt.hasSourceName(sty)) {
      ss << ctxt.getSourceName(sty);
    } else if(sname.find("struct.") == 0) {
      ss << "struct " << sname.substr(7);
    } else if(sname.find("class.") == 0) {
      ss << sname.substr(6);
    } else if(sname.find("union")) {
      ss << "union " << sname.substr(6);
    } else {
      ss << sname;
    }
    ss.flush();
    for(size_t i = 0; i < buf.length(); i++)
      if(buf[i] == '.')
        buf[i] = '_';
    return ctxt.add(sty, buf);
  } else {
    return ctxt.add(sty, ctxt.getNewVar("struct"));
  }
}

const cish::ASTBase& CishPass::handle(FunctionType* fty) {
  // Function types are probably even more of a headache in C and there
  // probably is a way of getting a a reasonable type without resorting to
  // typedefs but I don't know it. So just return something that looks more
  // like the LLVM string representation of a function type
  std::string buf;
  raw_string_ostream ss(buf);
  ss << handle(fty->getReturnType()) << "(";
  if(fty->getNumParams()) {
    ss << handle(fty->getParamType(0));
    for(unsigned i = 1; i < fty->getNumParams(); i++)
      ss << ", " << handle(fty->getParamType(i));
  }
  ss << ")";

  return ctxt.add(fty, ss.str());
}

const cish::ASTBase& CishPass::handle(VectorType* vty) {
  std::string buf;
  raw_string_ostream ss(buf);
  ss << handle(vty->getElementType()) << "<" << vty->getNumElements() << ">";

  return ctxt.add(vty, ss.str());
}

const cish::ASTBase& CishPass::handle(Type* type) {
  if(ctxt.has(type))
    return ctxt.get(type);

  if(auto* ity = dyn_cast<IntegerType>(type)) {
    return handle(ity);
  } else if(type->isVoidTy()) {
    return ctxt.add(type, "void");
  } else if(type->isFloatTy()) {
    return ctxt.add(type, "float");
  } else if(type->isDoubleTy()) {
    return ctxt.add(type, "double");
  } else if(type->isX86_FP80Ty()) {
    return ctxt.add(type, "long double");
  } else if(type->isFP128Ty()) {
    return ctxt.add(type, "long double");
  } else if(auto* pty = dyn_cast<PointerType>(type)) {
    return handle(pty);
  } else if(auto* aty = dyn_cast<ArrayType>(type)) {
    return handle(aty);
  } else if(auto* sty = dyn_cast<StructType>(type)) {
    return handle(sty);
  } else if(auto* fty = dyn_cast<FunctionType>(type)) {
    return handle(fty);
  } else if(auto* vty = dyn_cast<VectorType>(type)) {
    return handle(vty);
  } else {
    WithColor::error(errs()) << "Unknown type: " << *type << "\n";
    exit(1);
  }
}

void CishPass::initialize(const Function& f) {
  // In the preprocessing step, tag anything that we know are never going to be
  // converted. These would be any LLVM debug and lifetime intrinsics but
  // could be other things as well
  for(const Instruction& inst : instructions(f))
    if(const auto* call = dyn_cast<CallInst>(&inst))
      if(const Function* callee = call->getCalledFunction())
        if((callee->getName().find("llvm.dbg") == 0)
           or (callee->getName().find("llvm.lifetime") == 0))
          ignoreValues.insert(call);

  // Grow the ignore list to include anything that is only used by values in
  // the ignore list
  cish::Set<const llvm::Value*> wl = ignoreValues;
  while(wl.size()) {
    cish::Set<const Value*> next;
    for(const Value* v : wl)
      if(const auto* user = dyn_cast<User>(v))
        for(const Use& op : user->operands())
          if(allUsesIgnored(op.get()))
            next.insert(op.get());
    for(const Value* v : next)
      ignoreValues.insert(v);
    wl = std::move(next);
  }
}

void CishPass::initialize(const Module& m) {
  ctxt.parseSourceInformation(m);

  for(StructType* sty : m.getIdentifiedStructTypes()) {
    if(not ctxt.hasElementNames(sty)) {
      std::string buf;
      raw_string_ostream ss(buf);
      for(unsigned i = 0; i < sty->getNumElements(); i++) {
        ss << "f_" << i;
        ss.flush();
        ctxt.addElementName(sty, ss.str());
        buf.clear();
      }
    }
  }

  for(const Function& f : m.functions())
    if(f.size())
      initialize(f);
}

void CishPass::finalize(const Module& m) {
  // Delete any instructions that were created when processing ConstantExpr's.
  // Failure to do so will result in a broken module
  cexprs.clear();
}

bool CishPass::allUsesIgnored(const Value* v) const {
  if(v->getNumUses() == 0)
    return false;
  for(const Use& u : v->uses())
    if(not ignoreValues.contains(u.getUser()))
      return false;
  return true;
}

bool CishPass::shouldUseTemporary(const Instruction& inst) {
  // If there is zero or more than one use of the instruction, then create a
  // temporary variable for it. This is particularly important in the case
  // of function calls because if we don't do it this way and the result of
  // a call is used more than once, the call will appear to be made multiple
  // times, and if it is never used, then it will appear as if the call is
  // never made. But if we always use a temporary, the result will never
  // look remotely reasonable and we might as well just read LLVM.
  size_t uses = inst.getNumUses();
  // FIXME: Use llvm::CallBase for newer versions of LLVM
  if((isa<CallInst>(inst) or isa<InvokeInst>(inst))
     and (not inst.getType()->isVoidTy()) and ((uses == 0) or (uses > 1)))
    return true;
  else if(not isa<AllocaInst>(inst) and (uses > 1))
    return true;
  return false;
}

bool CishPass::runOnStruct(StructType* sty) {
  cc.reposition().add(handle(sty).str()).add(" {").endl().tab();
  for(unsigned i = 0; i < sty->getNumElements(); i++) {
    cc.reposition()
        .add(handle(sty->getElementType(i)))
        .space()
        .add(ctxt.getElementName(sty, i))
        .add(";")
        .endl();
  }
  cc.untab().add("};").endl().endl();

  return false;
}

bool CishPass::runOnGlobal(GlobalVariable& g) {
  WithColor::warning(errs()) << "UNIMPLEMENTED: Converting globals\n";
  return false;
}

bool CishPass::runOnFunction(Function& f) {
  handle(f);
  for(const Argument& arg : f.args())
    handle(arg);

  // LoopInfo& li = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
  // errs() << "loops: " << li.getLoopsInPreorder().size() << "\n";
  // for(const Loop* loop : li) {
  //   errs() << "Found a loop\n";
  //   // for(const BasicBlock* bb : loop->blocks())
  //   //   errs() << *bb << "\n";
  // }

  cc.begin_func(f);
  for(const BasicBlock& bb : f) {
    // Create a label for this basic block only if it is not the entry block
    // of the function. Unreachable basic blocks will probably only happen
    // in broken code, but that doesn't really matter
    if(not bb.hasNPredecessors(0))
      // The basic block may have been encountered before because it may
      // have appeared in a branch instruction that was seen earlier. In that
      // case, call handle() with BasicBlock* because that will check if
      // the basic block has already been converted
      cc.label(handle(&bb));

    for(const Instruction& inst : bb) {
      if(ignoreValues.contains(&inst))
        continue;

      if(const auto* alloca = dyn_cast<AllocaInst>(&inst)) {
        handle(*alloca);
        cc.add(ctxt.get<cish::Stmt>(alloca));
      } else if(const auto* call = dyn_cast<CallInst>(&inst)) {
        handle(*call);
        if(call->getType()->isVoidTy())
          cc.add(ctxt.get<cish::Stmt>(call));
      } else if(const auto* invoke = dyn_cast<InvokeInst>(&inst)) {
        handle(*invoke);
      } else if(const auto* load = dyn_cast<LoadInst>(&inst)) {
        handle(*load);
      } else if(const auto* store = dyn_cast<StoreInst>(&inst)) {
        cc.add(handle(*store));
      } else if(const auto* br = dyn_cast<BranchInst>(&inst)) {
        cc.add(handle(*br));
      } else if(const auto* ret = dyn_cast<ReturnInst>(&inst)) {
        cc.add(handle(ret));
      }

      if(shouldUseTemporary(inst)) {
        cc.reposition();
        std::string varName;
        if(ctxt.hasSourceName(inst)) {
          varName = ctxt.getSourceName(inst);
        } else {
          varName = ctxt.getNewVar();
          cc.add(handle(inst.getType())).space();
        }
        cc.add(varName).add(" = ").add(handle(&inst)).add(";").endl();
        ctxt.overwrite(inst, varName);
      }
    }
  }
  cc.end_func(f);
  cc.flush();

  return false;
}

bool CishPass::runOnModule(Module& m) {
  initialize(m);

  for(StructType* sty : m.getIdentifiedStructTypes())
    runOnStruct(sty);
  for(GlobalVariable& g : m.globals())
    runOnGlobal(g);
  for(Function& f : m.functions())
    if(f.size())
      runOnFunction(f);

  finalize(m);

  return false;
}

char CishPass::ID = 0;

static RegisterPass<CishPass> X("cish", "Cish Pass", true, true);
