#include "CishContext.h"
#include "DIParser.h"
#include "FormatOptions.h"
#include "LLVMParser.h"
#include "Printer.h"
#include "Set.h"
#include "Stream.h"

#include <clang/AST/ASTConsumer.h>
#include <clang/AST/ASTContext.h>
#include <clang/AST/RecursiveASTVisitor.h>
#include <clang/Basic/Builtins.h>

#include <llvm/IR/LLVMContext.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/InitializePasses.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/WithColor.h>
#include <llvm/Support/raw_ostream.h>

#include <unistd.h>

namespace cl = llvm::cl;

cl::OptionCategory cishOptionCategory("Cish Options", "");

static cl::list<cish::IgnoreCasts> optIgnoreCasts(
    "ignore-casts",
    cl::desc("Which casts, if any, to ignore"),
    cl::values(clEnumValN(cish::IgnoreCasts::Function,
                          "function",
                          "Ignore casts to function types"),
               clEnumValN(cish::IgnoreCasts::Vector,
                          "vector",
                          "Ignore casts to vector types"),
               clEnumValN(cish::IgnoreCasts::All, "all", "Ignore all casts")),
    cl::cat(cishOptionCategory));

static cl::opt<std::string> optPrefix(
    "prefix",
    cl::desc("The prefix to use for any names auto-generated by cish"),
    cl::init("c__"),
    cl::cat(cishOptionCategory));

static cl::list<cish::Annotations> optAnnotations(
    "annotate",
    cl::desc("Add annotations to the output"),
    cl::values(
        clEnumValN(cish::Annotations::Source,
                   "source",
                   "Annotate with source code if available"),
        clEnumValN(cish::Annotations::Cish,
                   "cish",
                   "Annotations from cish that may or may not be helpful"),
        clEnumValN(cish::Annotations::All, "all", "Add all annotations")),
    cl::cat(cishOptionCategory));

static cl::opt<cish::Indentation> optIndentation(
    "indentation",
    cl::desc("The indentation style to use"),
    cl::values(clEnumValN(cish::Indentation::KR, "kr", "K&R style"),
               clEnumValN(cish::Indentation::Allman, "allman", "Allman style"),
               clEnumValN(cish::Indentation::Stroustrup,
                          "stroupstrup",
                          "Stroustrup style")),
    cl::value_desc("style"),
    cl::init(cish::Indentation::KR),
    cl::cat(cishOptionCategory));

static cl::opt<unsigned>
    optOffset("offset",
              cl::desc("Number of spaces to use for indentation. If 0, tabs "
                       "are used instead of spaces"),
              cl::value_desc("<n>"),
              cl::init(4));

static cl::opt<bool> optQuiet("quiet",
                              cl::desc("Do not print any messages"),
                              cl::init(false),
                              cl::cat(cishOptionCategory));

static cl::opt<std::string> optOutput("o",
                                      cl::desc("Output file"),
                                      cl::value_desc("filename"),
                                      cl::init("-"));

static cl::opt<std::string> optFilename(cl::Positional,
                                        cl::desc("<input>"),
                                        cl::init("-"),
                                        cl::value_desc("filename"));

void initLLVM(int argc, char* argv[]) {
  llvm::InitializeAllAsmParsers();

  llvm::PassRegistry& Registry = *llvm::PassRegistry::getPassRegistry();
  llvm::initializeCore(Registry);
  llvm::initializeAnalysis(Registry);

  // This is a lousy hack but using LLVM's command line library ends up
  // populating it with a lot of options that are obviously not relevant
  // to this. Calling this with -help ends up displaying all of them which is
  // rather unpleasant. So just get rid of whatever we don't need
  cish::Set<std::string> optsKeep = {"help", "o"};
  for(auto& i : cl::getRegisteredOptions()) {
    llvm::StringRef key = i.first();
    cl::Option* opt = i.second;
    if(optsKeep.contains(key))
      opt->setDescription("Display available options");
    else if((opt->Category != &cishOptionCategory) and not opt->isPositional())
      i.second->removeArgument();
  }

  cl::ParseCommandLineOptions(argc, argv, "LLVM to C-ish converter\n");
  if(optOffset > 8) {
    llvm::WithColor::error(llvm::errs())
        << "Invalid value for offset. Min 0, Max 8\n";
    exit(1);
  }
}

int main(int argc, char* argv[]) {
  llvm::LLVMContext llvmContext;
  initLLVM(argc, argv);

  llvm::SMDiagnostic err;
  std::unique_ptr<llvm::Module> pModule
      = parseIRFile(optFilename, err, llvmContext);
  if(!pModule) {
    err.print(argv[0], llvm::errs());
    return 1;
  }

  // If we have a valid LLVM module, go through the whole rigmarole of
  // creating a clang ASTContext
  clang::FileSystemOptions fileOpts;
  clang::FileManager fileMgr(fileOpts);

  clang::IntrusiveRefCntPtr<clang::DiagnosticIDs> diagIDs(
      new clang::DiagnosticIDs());
  clang::IntrusiveRefCntPtr<clang::DiagnosticOptions> diagOpts(
      new clang::DiagnosticOptions());
  clang::DiagnosticsEngine diagEngine(diagIDs, diagOpts);
  clang::SourceManager srcMgr(diagEngine, fileMgr);

  clang::LangOptions langOpts;
  langOpts.CPlusPlus11 = true;
  langOpts.Bool = true;

  clang::IdentifierTable idents(langOpts);
  clang::Builtin::Context builtins;
  clang::SelectorTable sels;

  std::shared_ptr<clang::TargetOptions> targetOpts(new clang::TargetOptions());
  targetOpts->Triple = pModule->getTargetTriple();
  clang::TargetInfo& targetInfo
      = *clang::TargetInfo::CreateTargetInfo(diagEngine, targetOpts);

  clang::ASTContext astContext(langOpts, srcMgr, idents, sels, builtins);
  astContext.InitBuiltinTypes(targetInfo);

  cish::FormatOptions fmtOpts;
  fmtOpts.ignoreCasts.insert(optIgnoreCasts.begin(), optIgnoreCasts.end());
  fmtOpts.annotations.insert(optAnnotations.begin(), optAnnotations.end());
  fmtOpts.indentation = optIndentation;
  fmtOpts.offset = optOffset;

  // Now that the clang AST Context has been set up, get down to business
  cish::CishContext cishContext(optPrefix, astContext);
  cish::DIParser diParser;
  cish::LLVMParser llvmParser(cishContext, diParser);
  cish::Printer printer(astContext, fmtOpts);

  diParser.runOnModule(*pModule);
  llvmParser.runOnModule(*pModule);
  if(optOutput == "-") {
    llvm::raw_fd_ostream fs(STDOUT_FILENO, false);
    printer.run(fs);
  } else {
    std::error_code ec;
    llvm::raw_fd_ostream fs(optOutput, ec);
    if(ec) {
      llvm::WithColor(llvm::errs()) << ec.message() << "\n";
      exit(1);
    } else {
      printer.run(fs);
      fs.close();
    }
  }

  // for(IgnoreCasts ignore : OptIgnoreCasts)
  //   ignoreCasts.insert(ignore);

  // for(Annotations a : OptAnnotations)
  //   annotations.insert(a);

  // if(annotations.size())
  //   WithColor::warning(errs()) << "Annotations not implemented\n";

  llvm::llvm_shutdown();

  return 0;
}
