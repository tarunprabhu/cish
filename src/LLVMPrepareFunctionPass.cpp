//  ---------------------------------------------------------------------------
//  Copyright (C) 2020 Tarun Prabhu <tarun.prabhu@acm.org>
//
//  This file is part of Cish.
//
//  Cish is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Cish is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Cish.  If not, see <https://www.gnu.org/licenses/>.
//  ---------------------------------------------------------------------------

#include <llvm/Analysis/AssumptionCache.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Pass.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Utils.h>
#include <llvm/Transforms/Utils/Local.h>
#include <llvm/Transforms/Utils/PromoteMemToReg.h>

#include "CishLLVMContext.h"
#include "Diagnostics.h"
#include "LLVMSourceInfo.h"
#include "List.h"
#include "Logging.h"
#include "LLVMCishMetadata.h"
#include "LLVMUtils.h"
#include "Map.h"
#include "NameGenerator.h"
#include "Options.h"
#include "Set.h"
#include "Vector.h"

#include <regex>

using namespace llvm;
namespace LLVM = cish::LLVM;

class LLVMPrepareFunctionPass : public FunctionPass {
public:
  static char ID;

private:
  cish::CishLLVMContext& cishContext;

private:
  bool shouldPromote(AllocaInst* alloca) {
    // The safest ones to remove are those that are local to a basic block
    cish::Set<BasicBlock*> bbs;
    for(Use& u : alloca->uses())
      if(auto* inst = dyn_cast<Instruction>(u.getUser()))
        bbs.insert(inst->getParent());

    return bbs.size() <= 1;
  }

public:
  explicit LLVMPrepareFunctionPass(cish::CishLLVMContext& cishContext)
      : FunctionPass(ID), cishContext(cishContext) {
    ;
  }

  virtual StringRef getPassName() const override {
    return "Cish Prepare Function Pass";
  }

  virtual void getAnalysisUsage(AnalysisUsage& AU) const override {
    AU.addRequired<AssumptionCacheTracker>();
    AU.addRequired<DominatorTreeWrapperPass>();
    AU.addRequired<LoopInfoWrapperPass>();
  }

  virtual bool runOnFunction(Function& f) override {
    cish::message() << "Running " << getPassName() << " on " << f.getName()
                    << "\n";

    const cish::LLVMSourceInfo& si = cishContext.getLLVMSourceInfo();
    cish::NameGenerator& names = cishContext.addNameGenerator(f);
    DominatorTree& dt = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
    AssumptionCache& ac
        = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(f);
    LoopInfo& li = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();

    // Collect the known names
    for(const Argument& arg : f.args())
      if(si.hasName(arg))
        names.registerUserName(si.getName(arg));
    for(const Instruction& inst : instructions(f))
      if(const auto* alloca = dyn_cast<AllocaInst>(&inst))
        if(si.hasName(alloca))
          names.registerUserName(si.getName(alloca));

    // Re-promote some of the allocas generated by reg2mem. If this seems
    // ridiculous, it's because calling DemoteRegToMemory only for PHI Nodes
    // is not as straightforward as I would like
    std::vector<AllocaInst*> allocas;
    for(Instruction& inst : instructions(f)) {
      if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
        if(shouldPromote(alloca))
          allocas.push_back(alloca);
      }
    }
    PromoteMemToReg(allocas, dt, &ac);

    // Try to give the allocas more useful names if possible. Some of these
    // allocas probably correspond to variables in the source code. If debug
    // information is available, we can probably use it.
    // If the instruction has debug information associated with it, check if the
    // value is stored to an alloca. Pick the name most frequently stored to
    // the alloca and use it. This works on the assumption that the same
    // variable written to most often is likely to be the most useful in the
    // end result. But this is not always the case.

    // FIXME? (Maybe?): This is a bit hacky because it relies on
    // reg2mem naming the variables that it inserts a certain way.
    // Those are unlikely to change, but you never know
    std::regex re("^(.*)[.]reg2mem[.]?[0-9]*$");
    for(Instruction& inst : instructions(f)) {
      if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
        std::string name = alloca->getName().str();
        if(std::regex_match(name, re)) {
          cish::Map<std::string, unsigned> srcNames;
          for(Use& u : alloca->uses())
            if(auto* store = dyn_cast<StoreInst>(u.getUser()))
              if(si.hasName(store->getValueOperand()))
                ++srcNames[si.getName(store->getValueOperand())];
          if(srcNames.size())
            alloca->setName(names.getAmbiguousUserName(
                std::max_element(srcNames.begin(),
                                 srcNames.end(),
                                 [](const auto& a, const auto& b) {
                                   return a.second < b.second;
                                 })
                    ->first,
                false));
          else
            alloca->setName(names.getNewVarName());
        }
      } else {
        inst.getParent()->splitBasicBlock(&inst);
        break;
      }
    }

    // Move the branch instruction in the exiting branch of a loop to its own
    // basic block. Also make the header an empty block so it only acts as
    // the target of a backedge and does nothing else
    cish::List<Loop*> loops = LLVM::collectLoops(li);
    cish::Map<BasicBlock*, Loop*> preheaders;
    for(Loop* loop : loops) {
      SmallVector<BasicBlock*, 4> exiting;
      loop->getExitingBlocks(exiting);
      for(BasicBlock* bb : exiting)
        bb->splitBasicBlock(&bb->back());
      BasicBlock* header = loop->getHeader();
      header->splitBasicBlock(&header->front());
      if(BasicBlock* preheader = loop->getLoopPreheader())
        preheaders[preheader] = loop;
    }

    // Move switch instructions into their own basic block
    cish::List<Instruction*> switches;
    for(Instruction& inst : instructions(f))
      if(isa<SwitchInst>(inst))
        switches.push_back(&inst);
    for(Instruction* inst : switches)
      inst->getParent()->splitBasicBlock(inst);

    cish::Map<AllocaInst*, cish::Set<Loop*>> usesInLoops;
    for(Instruction& inst : instructions(f)) {
      if(auto* alloca = dyn_cast<AllocaInst>(&inst)) {
        for(Use& u : alloca->uses()) {
          if(auto* i = dyn_cast<Instruction>(u.getUser())) {
            if(isa<LoadInst>(u.getUser()) or isa<StoreInst>(u.getUser())) {
              BasicBlock* bb = i->getParent();
              if(Loop* loop = li.getLoopFor(bb))
                usesInLoops[alloca].insert(loop);
              if(preheaders.contains(bb))
                usesInLoops[alloca].insert(preheaders.at(bb));
            }
          }
        }
      }
    }

    // Add metadata
    for(Instruction& inst : instructions(f))
      if(isa<ResumeInst>(inst) or isa<UnreachableInst>(inst))
        LLVM::addCishMetadataIgnore(inst);

    if(cish::opts().has(cish::LogCategory::IR))
      if(cish::Logger log
         = cish::Logger::openFile(f.getName(), "prepared", "ll"))
        log() << *f.getParent();

    return true;
  }
};

char LLVMPrepareFunctionPass::ID = 0;

Pass* createLLVMPrepareFunctionPass(cish::CishLLVMContext& cishContext) {
  return new LLVMPrepareFunctionPass(cishContext);
}
